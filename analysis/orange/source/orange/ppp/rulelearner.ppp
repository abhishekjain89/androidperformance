 /* This file has been generated by pyprops.py.
       (feel free to edit it and pyprops will feel free to undo your changes). */
#include "../rulelearner.hpp"
#include <cstddef>



/****** TRule *****/


TPropertyDescription TRule_properties[] = {
  {"filter", "stored filter for this rule", &typeid(POrange), &TFilter::st_classDescription, offsetof(TRule, filter), false, false, 0},
  {"values_filter", "Filter_values representation of main filter (sometimes needed)", &typeid(POrange), &TFilter::st_classDescription, offsetof(TRule, valuesFilter), false, false, 0},
  {"classifier", "classifies an example", &typeid(POrange), &TClassifier::st_classDescription, offsetof(TRule, classifier), false, false, 0},
  {"learner", "learns a classifier from data", &typeid(POrange), &TLearner::st_classDescription, offsetof(TRule, learner), false, false, 0},
  {"parent_rule", "", &typeid(POrange), &TRule::st_classDescription, offsetof(TRule, parentRule), false, false, 0},
  {"base_dist", "initial distribution", &typeid(POrange), &TDistribution::st_classDescription, offsetof(TRule, baseDist), false, false, 0},
  {"class_distribution", "distribution of classes covered by the rule", &typeid(POrange), &TDistribution::st_classDescription, offsetof(TRule, classDistribution), false, false, 0},
  {"examples", "covered examples", &typeid(POrange), &TExampleTable::st_classDescription, offsetof(TRule, examples), false, false, 0},
  {"weight_ID", "weight for the stored examples", &typeid(int), NULL, offsetof(TRule, weightID), false, false, 0},
  {"quality", "some measure of rule quality", &typeid(float), NULL, offsetof(TRule, quality), false, false, 0},
  {"complexity", "", &typeid(int), NULL, offsetof(TRule, complexity), false, false, 0},
  {"chi", "", &typeid(float), NULL, offsetof(TRule, chi), false, false, 0},
  {"required_conditions", "conditions that are mandatory in rule - rule attribute significance avoids these", &typeid(int), NULL, offsetof(TRule, requiredConditions), false, false, 0},
  {NULL}
};

size_t const TRule_components[] = { offsetof(TRule, filter), offsetof(TRule, valuesFilter), offsetof(TRule, classifier), offsetof(TRule, learner), offsetof(TRule, parentRule), offsetof(TRule, baseDist), offsetof(TRule, classDistribution), offsetof(TRule, examples), 0};
TClassDescription TRule::st_classDescription = { "TRule", &typeid(TRule), &TOrange::st_classDescription, TRule_properties, TRule_components };
TClassDescription const *TRule::classDescription() const { return &TRule::st_classDescription; }
TOrange *TRule::clone() const { return mlnew TRule(*this); }


/****** TRuleValidator *****/


TPropertyDescription TRuleValidator_properties[] = {
  {NULL}
};

size_t const TRuleValidator_components[] = { 0};
TClassDescription TRuleValidator::st_classDescription = { "TRuleValidator", &typeid(TRuleValidator), &TOrange::st_classDescription, TRuleValidator_properties, TRuleValidator_components };
TClassDescription const *TRuleValidator::classDescription() const { return &TRuleValidator::st_classDescription; }


/****** TRuleValidator_LRS *****/


TPropertyDescription TRuleValidator_LRS_properties[] = {
  {"alpha", "", &typeid(float), NULL, offsetof(TRuleValidator_LRS, alpha), false, false, 0},
  {"min_coverage", "", &typeid(float), NULL, offsetof(TRuleValidator_LRS, min_coverage), false, false, 0},
  {"max_rule_complexity", "", &typeid(int), NULL, offsetof(TRuleValidator_LRS, max_rule_complexity), false, false, 0},
  {"min_quality", "", &typeid(float), NULL, offsetof(TRuleValidator_LRS, min_quality), false, false, 0},
  {NULL}
};

size_t const TRuleValidator_LRS_components[] = { 0};
TClassDescription TRuleValidator_LRS::st_classDescription = { "TRuleValidator_LRS", &typeid(TRuleValidator_LRS), &TRuleValidator::st_classDescription, TRuleValidator_LRS_properties, TRuleValidator_LRS_components };
TClassDescription const *TRuleValidator_LRS::classDescription() const { return &TRuleValidator_LRS::st_classDescription; }
TOrange *TRuleValidator_LRS::clone() const { return mlnew TRuleValidator_LRS(*this); }


/****** TRuleEvaluator *****/


TPropertyDescription TRuleEvaluator_properties[] = {
  {NULL}
};

size_t const TRuleEvaluator_components[] = { 0};
TClassDescription TRuleEvaluator::st_classDescription = { "TRuleEvaluator", &typeid(TRuleEvaluator), &TOrange::st_classDescription, TRuleEvaluator_properties, TRuleEvaluator_components };
TClassDescription const *TRuleEvaluator::classDescription() const { return &TRuleEvaluator::st_classDescription; }


/****** TRuleEvaluator_Entropy *****/


TPropertyDescription TRuleEvaluator_Entropy_properties[] = {
  {NULL}
};

size_t const TRuleEvaluator_Entropy_components[] = { 0};
TClassDescription TRuleEvaluator_Entropy::st_classDescription = { "TRuleEvaluator_Entropy", &typeid(TRuleEvaluator_Entropy), &TRuleEvaluator::st_classDescription, TRuleEvaluator_Entropy_properties, TRuleEvaluator_Entropy_components };
TClassDescription const *TRuleEvaluator_Entropy::classDescription() const { return &TRuleEvaluator_Entropy::st_classDescription; }
TOrange *TRuleEvaluator_Entropy::clone() const { return mlnew TRuleEvaluator_Entropy(*this); }


/****** TRuleEvaluator_Laplace *****/


TPropertyDescription TRuleEvaluator_Laplace_properties[] = {
  {NULL}
};

size_t const TRuleEvaluator_Laplace_components[] = { 0};
TClassDescription TRuleEvaluator_Laplace::st_classDescription = { "TRuleEvaluator_Laplace", &typeid(TRuleEvaluator_Laplace), &TRuleEvaluator::st_classDescription, TRuleEvaluator_Laplace_properties, TRuleEvaluator_Laplace_components };
TClassDescription const *TRuleEvaluator_Laplace::classDescription() const { return &TRuleEvaluator_Laplace::st_classDescription; }
TOrange *TRuleEvaluator_Laplace::clone() const { return mlnew TRuleEvaluator_Laplace(*this); }


/****** TEVDist *****/


TPropertyDescription TEVDist_properties[] = {
  {"mu", "mu of Fisher-Tippett distribution", &typeid(float), NULL, offsetof(TEVDist, mu), false, false, 0},
  {"beta", "beta of Fisher-Tippett distribution", &typeid(float), NULL, offsetof(TEVDist, beta), false, false, 0},
  {"percentiles", "usually 10 values - 0 = 5th percentile, 1 = 15th percentile, 9 = 95th percentile, change maxPercentile and step for other settings", &typeid(POrange), &TFloatList::st_classDescription, offsetof(TEVDist, percentiles), false, false, 0},
  {"max_percentile", "maxPercentile Value, default 0.95", &typeid(float), NULL, offsetof(TEVDist, maxPercentile), false, false, 0},
  {"step", "step of percentiles, default 0.1", &typeid(float), NULL, offsetof(TEVDist, step), false, false, 0},
  {NULL}
};

size_t const TEVDist_components[] = { offsetof(TEVDist, percentiles), 0};
TClassDescription TEVDist::st_classDescription = { "TEVDist", &typeid(TEVDist), &TOrange::st_classDescription, TEVDist_properties, TEVDist_components };
TClassDescription const *TEVDist::classDescription() const { return &TEVDist::st_classDescription; }
TOrange *TEVDist::clone() const { return mlnew TEVDist(*this); }


/****** TEVDistGetter *****/


TPropertyDescription TEVDistGetter_properties[] = {
  {NULL}
};

size_t const TEVDistGetter_components[] = { 0};
TClassDescription TEVDistGetter::st_classDescription = { "TEVDistGetter", &typeid(TEVDistGetter), &TOrange::st_classDescription, TEVDistGetter_properties, TEVDistGetter_components };
TClassDescription const *TEVDistGetter::classDescription() const { return &TEVDistGetter::st_classDescription; }


/****** TEVDistGetter_Standard *****/


TPropertyDescription TEVDistGetter_Standard_properties[] = {
  {"dists", "EVC distribution (sorted by rule length, 0 = for rules without conditions)", &typeid(POrange), &TEVDistList::st_classDescription, offsetof(TEVDistGetter_Standard, dists), false, false, 0},
  {NULL}
};

size_t const TEVDistGetter_Standard_components[] = { offsetof(TEVDistGetter_Standard, dists), 0};
TClassDescription TEVDistGetter_Standard::st_classDescription = { "TEVDistGetter_Standard", &typeid(TEVDistGetter_Standard), &TEVDistGetter::st_classDescription, TEVDistGetter_Standard_properties, TEVDistGetter_Standard_components };
TClassDescription const *TEVDistGetter_Standard::classDescription() const { return &TEVDistGetter_Standard::st_classDescription; }
TOrange *TEVDistGetter_Standard::clone() const { return mlnew TEVDistGetter_Standard(*this); }


/****** TRuleEvaluator_mEVC *****/


TPropertyDescription TRuleEvaluator_mEVC_properties[] = {
  {"m", "Parameter m for m-estimate after EVC correction", &typeid(float), NULL, offsetof(TRuleEvaluator_mEVC, m), false, false, 0},
  {"ev_dist_getter", "get EVC distribution for chi correction", &typeid(POrange), &TEVDistGetter::st_classDescription, offsetof(TRuleEvaluator_mEVC, evDistGetter), false, false, 0},
  {"prob_var", "probability coverage variable (meta usually)", &typeid(POrange), &TVariable::st_classDescription, offsetof(TRuleEvaluator_mEVC, probVar), false, false, 0},
  {"validator", "rule validator for best rule", &typeid(POrange), &TRuleValidator::st_classDescription, offsetof(TRuleEvaluator_mEVC, validator), false, false, 0},
  {"min_improved", "minimal number of improved examples", &typeid(int), NULL, offsetof(TRuleEvaluator_mEVC, min_improved), false, false, 0},
  {"min_improved_perc", "minimal percentage of improved examples", &typeid(float), NULL, offsetof(TRuleEvaluator_mEVC, min_improved_perc), false, false, 0},
  {"best_rule", "best rule found and evaluated given conditions (min_improved, validator)", &typeid(POrange), &TRule::st_classDescription, offsetof(TRuleEvaluator_mEVC, bestRule), false, false, 0},
  {"rule_alpha", "minimal 'true' rule significance", &typeid(float), NULL, offsetof(TRuleEvaluator_mEVC, ruleAlpha), false, false, 0},
  {"attribute_alpha", "minimal attribute significance", &typeid(float), NULL, offsetof(TRuleEvaluator_mEVC, attributeAlpha), false, false, 0},
  {"return_expected_prob", "if true, evaluator returns expected class probability, if false, current class probability", &typeid(bool), NULL, offsetof(TRuleEvaluator_mEVC, returnExpectedProb), false, false, 0},
  {"optimism_reduction", "to select optimstic (0), pessimistic (1) or EVC (2) evaluation", &typeid(int), NULL, offsetof(TRuleEvaluator_mEVC, optimismReduction), false, false, 0},
  {NULL}
};

size_t const TRuleEvaluator_mEVC_components[] = { offsetof(TRuleEvaluator_mEVC, evDistGetter), offsetof(TRuleEvaluator_mEVC, probVar), offsetof(TRuleEvaluator_mEVC, validator), offsetof(TRuleEvaluator_mEVC, bestRule), 0};
TClassDescription TRuleEvaluator_mEVC::st_classDescription = { "TRuleEvaluator_mEVC", &typeid(TRuleEvaluator_mEVC), &TRuleEvaluator::st_classDescription, TRuleEvaluator_mEVC_properties, TRuleEvaluator_mEVC_components };
TClassDescription const *TRuleEvaluator_mEVC::classDescription() const { return &TRuleEvaluator_mEVC::st_classDescription; }
TOrange *TRuleEvaluator_mEVC::clone() const { return mlnew TRuleEvaluator_mEVC(*this); }


/****** TRuleEvaluator_LRS *****/


TPropertyDescription TRuleEvaluator_LRS_properties[] = {
  {"rules", "", &typeid(POrange), &TRuleList::st_classDescription, offsetof(TRuleEvaluator_LRS, rules), false, false, 0},
  {"store_rules", "", &typeid(bool), NULL, offsetof(TRuleEvaluator_LRS, storeRules), false, false, 0},
  {NULL}
};

size_t const TRuleEvaluator_LRS_components[] = { offsetof(TRuleEvaluator_LRS, rules), 0};
TClassDescription TRuleEvaluator_LRS::st_classDescription = { "TRuleEvaluator_LRS", &typeid(TRuleEvaluator_LRS), &TRuleEvaluator::st_classDescription, TRuleEvaluator_LRS_properties, TRuleEvaluator_LRS_components };
TClassDescription const *TRuleEvaluator_LRS::classDescription() const { return &TRuleEvaluator_LRS::st_classDescription; }
TOrange *TRuleEvaluator_LRS::clone() const { return mlnew TRuleEvaluator_LRS(*this); }


/****** TRuleFinder *****/


TPropertyDescription TRuleFinder_properties[] = {
  {"validator", "", &typeid(POrange), &TRuleValidator::st_classDescription, offsetof(TRuleFinder, validator), false, false, 0},
  {"evaluator", "", &typeid(POrange), &TRuleEvaluator::st_classDescription, offsetof(TRuleFinder, evaluator), false, false, 0},
  {NULL}
};

size_t const TRuleFinder_components[] = { offsetof(TRuleFinder, validator), offsetof(TRuleFinder, evaluator), 0};
TClassDescription TRuleFinder::st_classDescription = { "TRuleFinder", &typeid(TRuleFinder), &TOrange::st_classDescription, TRuleFinder_properties, TRuleFinder_components };
TClassDescription const *TRuleFinder::classDescription() const { return &TRuleFinder::st_classDescription; }


/****** TRuleBeamInitializer *****/


TPropertyDescription TRuleBeamInitializer_properties[] = {
  {NULL}
};

size_t const TRuleBeamInitializer_components[] = { 0};
TClassDescription TRuleBeamInitializer::st_classDescription = { "TRuleBeamInitializer", &typeid(TRuleBeamInitializer), &TOrange::st_classDescription, TRuleBeamInitializer_properties, TRuleBeamInitializer_components };
TClassDescription const *TRuleBeamInitializer::classDescription() const { return &TRuleBeamInitializer::st_classDescription; }


/****** TRuleBeamInitializer_Default *****/


TPropertyDescription TRuleBeamInitializer_Default_properties[] = {
  {NULL}
};

size_t const TRuleBeamInitializer_Default_components[] = { 0};
TClassDescription TRuleBeamInitializer_Default::st_classDescription = { "TRuleBeamInitializer_Default", &typeid(TRuleBeamInitializer_Default), &TRuleBeamInitializer::st_classDescription, TRuleBeamInitializer_Default_properties, TRuleBeamInitializer_Default_components };
TClassDescription const *TRuleBeamInitializer_Default::classDescription() const { return &TRuleBeamInitializer_Default::st_classDescription; }
TOrange *TRuleBeamInitializer_Default::clone() const { return mlnew TRuleBeamInitializer_Default(*this); }


/****** TRuleBeamRefiner *****/


TPropertyDescription TRuleBeamRefiner_properties[] = {
  {NULL}
};

size_t const TRuleBeamRefiner_components[] = { 0};
TClassDescription TRuleBeamRefiner::st_classDescription = { "TRuleBeamRefiner", &typeid(TRuleBeamRefiner), &TOrange::st_classDescription, TRuleBeamRefiner_properties, TRuleBeamRefiner_components };
TClassDescription const *TRuleBeamRefiner::classDescription() const { return &TRuleBeamRefiner::st_classDescription; }


/****** TRuleBeamRefiner_Selector *****/


TPropertyDescription TRuleBeamRefiner_Selector_properties[] = {
  {"discretization", "discretization for continuous attributes", &typeid(POrange), &TDiscretization::st_classDescription, offsetof(TRuleBeamRefiner_Selector, discretization), false, false, 0},
  {NULL}
};

size_t const TRuleBeamRefiner_Selector_components[] = { offsetof(TRuleBeamRefiner_Selector, discretization), 0};
TClassDescription TRuleBeamRefiner_Selector::st_classDescription = { "TRuleBeamRefiner_Selector", &typeid(TRuleBeamRefiner_Selector), &TRuleBeamRefiner::st_classDescription, TRuleBeamRefiner_Selector_properties, TRuleBeamRefiner_Selector_components };
TClassDescription const *TRuleBeamRefiner_Selector::classDescription() const { return &TRuleBeamRefiner_Selector::st_classDescription; }
TOrange *TRuleBeamRefiner_Selector::clone() const { return mlnew TRuleBeamRefiner_Selector(*this); }


/****** TRuleBeamCandidateSelector *****/


TPropertyDescription TRuleBeamCandidateSelector_properties[] = {
  {NULL}
};

size_t const TRuleBeamCandidateSelector_components[] = { 0};
TClassDescription TRuleBeamCandidateSelector::st_classDescription = { "TRuleBeamCandidateSelector", &typeid(TRuleBeamCandidateSelector), &TOrange::st_classDescription, TRuleBeamCandidateSelector_properties, TRuleBeamCandidateSelector_components };
TClassDescription const *TRuleBeamCandidateSelector::classDescription() const { return &TRuleBeamCandidateSelector::st_classDescription; }


/****** TRuleBeamCandidateSelector_TakeAll *****/


TPropertyDescription TRuleBeamCandidateSelector_TakeAll_properties[] = {
  {NULL}
};

size_t const TRuleBeamCandidateSelector_TakeAll_components[] = { 0};
TClassDescription TRuleBeamCandidateSelector_TakeAll::st_classDescription = { "TRuleBeamCandidateSelector_TakeAll", &typeid(TRuleBeamCandidateSelector_TakeAll), &TRuleBeamCandidateSelector::st_classDescription, TRuleBeamCandidateSelector_TakeAll_properties, TRuleBeamCandidateSelector_TakeAll_components };
TClassDescription const *TRuleBeamCandidateSelector_TakeAll::classDescription() const { return &TRuleBeamCandidateSelector_TakeAll::st_classDescription; }
TOrange *TRuleBeamCandidateSelector_TakeAll::clone() const { return mlnew TRuleBeamCandidateSelector_TakeAll(*this); }


/****** TRuleBeamFilter *****/


TPropertyDescription TRuleBeamFilter_properties[] = {
  {NULL}
};

size_t const TRuleBeamFilter_components[] = { 0};
TClassDescription TRuleBeamFilter::st_classDescription = { "TRuleBeamFilter", &typeid(TRuleBeamFilter), &TOrange::st_classDescription, TRuleBeamFilter_properties, TRuleBeamFilter_components };
TClassDescription const *TRuleBeamFilter::classDescription() const { return &TRuleBeamFilter::st_classDescription; }


/****** TRuleBeamFilter_Width *****/


TPropertyDescription TRuleBeamFilter_Width_properties[] = {
  {"width", "", &typeid(int), NULL, offsetof(TRuleBeamFilter_Width, width), false, false, 0},
  {NULL}
};

size_t const TRuleBeamFilter_Width_components[] = { 0};
TClassDescription TRuleBeamFilter_Width::st_classDescription = { "TRuleBeamFilter_Width", &typeid(TRuleBeamFilter_Width), &TRuleBeamFilter::st_classDescription, TRuleBeamFilter_Width_properties, TRuleBeamFilter_Width_components };
TClassDescription const *TRuleBeamFilter_Width::classDescription() const { return &TRuleBeamFilter_Width::st_classDescription; }
TOrange *TRuleBeamFilter_Width::clone() const { return mlnew TRuleBeamFilter_Width(*this); }


/****** TRuleBeamFinder *****/


TPropertyDescription TRuleBeamFinder_properties[] = {
  {"initializer", "", &typeid(POrange), &TRuleBeamInitializer::st_classDescription, offsetof(TRuleBeamFinder, initializer), false, false, 0},
  {"refiner", "", &typeid(POrange), &TRuleBeamRefiner::st_classDescription, offsetof(TRuleBeamFinder, refiner), false, false, 0},
  {"candidate_selector", "", &typeid(POrange), &TRuleBeamCandidateSelector::st_classDescription, offsetof(TRuleBeamFinder, candidateSelector), false, false, 0},
  {"rule_filter", "", &typeid(POrange), &TRuleBeamFilter::st_classDescription, offsetof(TRuleBeamFinder, ruleFilter), false, false, 0},
  {"rule_stopping_validator", "", &typeid(POrange), &TRuleValidator::st_classDescription, offsetof(TRuleBeamFinder, ruleStoppingValidator), false, false, 0},
  {"validator", "", &typeid(POrange), &TRuleValidator::st_classDescription, offsetof(TRuleBeamFinder, validator), false, false, 0},
  {"evaluator", "", &typeid(POrange), &TRuleEvaluator::st_classDescription, offsetof(TRuleBeamFinder, evaluator), false, false, 0},
  {NULL}
};

size_t const TRuleBeamFinder_components[] = { offsetof(TRuleBeamFinder, initializer), offsetof(TRuleBeamFinder, refiner), offsetof(TRuleBeamFinder, candidateSelector), offsetof(TRuleBeamFinder, ruleFilter), offsetof(TRuleBeamFinder, ruleStoppingValidator), offsetof(TRuleBeamFinder, validator), offsetof(TRuleBeamFinder, evaluator), 0};
TClassDescription TRuleBeamFinder::st_classDescription = { "TRuleBeamFinder", &typeid(TRuleBeamFinder), &TRuleFinder::st_classDescription, TRuleBeamFinder_properties, TRuleBeamFinder_components };
TClassDescription const *TRuleBeamFinder::classDescription() const { return &TRuleBeamFinder::st_classDescription; }
TOrange *TRuleBeamFinder::clone() const { return mlnew TRuleBeamFinder(*this); }


/****** TRuleDataStoppingCriteria *****/


TPropertyDescription TRuleDataStoppingCriteria_properties[] = {
  {NULL}
};

size_t const TRuleDataStoppingCriteria_components[] = { 0};
TClassDescription TRuleDataStoppingCriteria::st_classDescription = { "TRuleDataStoppingCriteria", &typeid(TRuleDataStoppingCriteria), &TOrange::st_classDescription, TRuleDataStoppingCriteria_properties, TRuleDataStoppingCriteria_components };
TClassDescription const *TRuleDataStoppingCriteria::classDescription() const { return &TRuleDataStoppingCriteria::st_classDescription; }


/****** TRuleDataStoppingCriteria_NoPositives *****/


TPropertyDescription TRuleDataStoppingCriteria_NoPositives_properties[] = {
  {NULL}
};

size_t const TRuleDataStoppingCriteria_NoPositives_components[] = { 0};
TClassDescription TRuleDataStoppingCriteria_NoPositives::st_classDescription = { "TRuleDataStoppingCriteria_NoPositives", &typeid(TRuleDataStoppingCriteria_NoPositives), &TRuleDataStoppingCriteria::st_classDescription, TRuleDataStoppingCriteria_NoPositives_properties, TRuleDataStoppingCriteria_NoPositives_components };
TClassDescription const *TRuleDataStoppingCriteria_NoPositives::classDescription() const { return &TRuleDataStoppingCriteria_NoPositives::st_classDescription; }
TOrange *TRuleDataStoppingCriteria_NoPositives::clone() const { return mlnew TRuleDataStoppingCriteria_NoPositives(*this); }


/****** TRuleStoppingCriteria *****/


TPropertyDescription TRuleStoppingCriteria_properties[] = {
  {NULL}
};

size_t const TRuleStoppingCriteria_components[] = { 0};
TClassDescription TRuleStoppingCriteria::st_classDescription = { "TRuleStoppingCriteria", &typeid(TRuleStoppingCriteria), &TOrange::st_classDescription, TRuleStoppingCriteria_properties, TRuleStoppingCriteria_components };
TClassDescription const *TRuleStoppingCriteria::classDescription() const { return &TRuleStoppingCriteria::st_classDescription; }


/****** TRuleStoppingCriteria_NegativeDistribution *****/


TPropertyDescription TRuleStoppingCriteria_NegativeDistribution_properties[] = {
  {NULL}
};

size_t const TRuleStoppingCriteria_NegativeDistribution_components[] = { 0};
TClassDescription TRuleStoppingCriteria_NegativeDistribution::st_classDescription = { "TRuleStoppingCriteria_NegativeDistribution", &typeid(TRuleStoppingCriteria_NegativeDistribution), &TRuleStoppingCriteria::st_classDescription, TRuleStoppingCriteria_NegativeDistribution_properties, TRuleStoppingCriteria_NegativeDistribution_components };
TClassDescription const *TRuleStoppingCriteria_NegativeDistribution::classDescription() const { return &TRuleStoppingCriteria_NegativeDistribution::st_classDescription; }
TOrange *TRuleStoppingCriteria_NegativeDistribution::clone() const { return mlnew TRuleStoppingCriteria_NegativeDistribution(*this); }


/****** TRuleCovererAndRemover *****/


TPropertyDescription TRuleCovererAndRemover_properties[] = {
  {NULL}
};

size_t const TRuleCovererAndRemover_components[] = { 0};
TClassDescription TRuleCovererAndRemover::st_classDescription = { "TRuleCovererAndRemover", &typeid(TRuleCovererAndRemover), &TOrange::st_classDescription, TRuleCovererAndRemover_properties, TRuleCovererAndRemover_components };
TClassDescription const *TRuleCovererAndRemover::classDescription() const { return &TRuleCovererAndRemover::st_classDescription; }


/****** TRuleCovererAndRemover_Default *****/


TPropertyDescription TRuleCovererAndRemover_Default_properties[] = {
  {NULL}
};

size_t const TRuleCovererAndRemover_Default_components[] = { 0};
TClassDescription TRuleCovererAndRemover_Default::st_classDescription = { "TRuleCovererAndRemover_Default", &typeid(TRuleCovererAndRemover_Default), &TRuleCovererAndRemover::st_classDescription, TRuleCovererAndRemover_Default_properties, TRuleCovererAndRemover_Default_components };
TClassDescription const *TRuleCovererAndRemover_Default::classDescription() const { return &TRuleCovererAndRemover_Default::st_classDescription; }
TOrange *TRuleCovererAndRemover_Default::clone() const { return mlnew TRuleCovererAndRemover_Default(*this); }


/****** TRuleClassifierConstructor *****/


TPropertyDescription TRuleClassifierConstructor_properties[] = {
  {NULL}
};

size_t const TRuleClassifierConstructor_components[] = { 0};
TClassDescription TRuleClassifierConstructor::st_classDescription = { "TRuleClassifierConstructor", &typeid(TRuleClassifierConstructor), &TOrange::st_classDescription, TRuleClassifierConstructor_properties, TRuleClassifierConstructor_components };
TClassDescription const *TRuleClassifierConstructor::classDescription() const { return &TRuleClassifierConstructor::st_classDescription; }


/****** TRuleClassifierConstructor_firstRule *****/


TPropertyDescription TRuleClassifierConstructor_firstRule_properties[] = {
  {NULL}
};

size_t const TRuleClassifierConstructor_firstRule_components[] = { 0};
TClassDescription TRuleClassifierConstructor_firstRule::st_classDescription = { "TRuleClassifierConstructor_firstRule", &typeid(TRuleClassifierConstructor_firstRule), &TRuleClassifierConstructor::st_classDescription, TRuleClassifierConstructor_firstRule_properties, TRuleClassifierConstructor_firstRule_components };
TClassDescription const *TRuleClassifierConstructor_firstRule::classDescription() const { return &TRuleClassifierConstructor_firstRule::st_classDescription; }
TOrange *TRuleClassifierConstructor_firstRule::clone() const { return mlnew TRuleClassifierConstructor_firstRule(*this); }


/****** TRuleLearner *****/


TPropertyDescription TRuleLearner_properties[] = {
  {"data_stopping", "", &typeid(POrange), &TRuleDataStoppingCriteria::st_classDescription, offsetof(TRuleLearner, dataStopping), false, false, 0},
  {"rule_stopping", "", &typeid(POrange), &TRuleStoppingCriteria::st_classDescription, offsetof(TRuleLearner, ruleStopping), false, false, 0},
  {"cover_and_remove", "", &typeid(POrange), &TRuleCovererAndRemover::st_classDescription, offsetof(TRuleLearner, coverAndRemove), false, false, 0},
  {"rule_finder", "", &typeid(POrange), &TRuleFinder::st_classDescription, offsetof(TRuleLearner, ruleFinder), false, false, 0},
  {"classifier_constructor", "classifier", &typeid(POrange), &TRuleClassifierConstructor::st_classDescription, offsetof(TRuleLearner, classifierConstructor), false, false, 0},
  {"progress_callback", "progress callback function", &typeid(POrange), &TProgressCallback::st_classDescription, offsetof(TRuleLearner, progressCallback), false, false, 0},
  {"store_examples", "", &typeid(bool), NULL, offsetof(TRuleLearner, storeExamples), false, false, 0},
  {"target_class", "", &typeid(int), NULL, offsetof(TRuleLearner, targetClass), false, false, 0},
  {"base_rules", "", &typeid(POrange), &TRuleList::st_classDescription, offsetof(TRuleLearner, baseRules), false, false, 0},
  {"needs", "the kind of data that learner needs", &typeid(int), NULL, offsetof(TRuleLearner, needs), true, false, 0},
  {NULL}
};

size_t const TRuleLearner_components[] = { offsetof(TRuleLearner, dataStopping), offsetof(TRuleLearner, ruleStopping), offsetof(TRuleLearner, coverAndRemove), offsetof(TRuleLearner, ruleFinder), offsetof(TRuleLearner, classifierConstructor), offsetof(TRuleLearner, progressCallback), offsetof(TRuleLearner, baseRules), 0};
TClassDescription TRuleLearner::st_classDescription = { "TRuleLearner", &typeid(TRuleLearner), &TLearner::st_classDescription, TRuleLearner_properties, TRuleLearner_components };
TClassDescription const *TRuleLearner::classDescription() const { return &TRuleLearner::st_classDescription; }
TOrange *TRuleLearner::clone() const { return mlnew TRuleLearner(*this); }


/****** TRuleClassifier *****/


TPropertyDescription TRuleClassifier_properties[] = {
  {"rules", "", &typeid(POrange), &TRuleList::st_classDescription, offsetof(TRuleClassifier, rules), false, false, 0},
  {"examples", "", &typeid(POrange), &TExampleTable::st_classDescription, offsetof(TRuleClassifier, examples), false, false, 0},
  {"weight_ID", "", &typeid(int), NULL, offsetof(TRuleClassifier, weightID), false, false, 0},
  {"class_var", "class variable", &typeid(POrange), &TVariable::st_classDescription, offsetof(TRuleClassifier, classVar), false, false, 0},
  {"computes_probabilities", "set if classifier computes class probabilities (if not, it assigns 1.0 to the predicted)", &typeid(bool), NULL, offsetof(TRuleClassifier, computesProbabilities), false, false, 0},
  {NULL}
};

size_t const TRuleClassifier_components[] = { offsetof(TRuleClassifier, rules), offsetof(TRuleClassifier, examples), offsetof(TRuleClassifier, classVar), 0};
TClassDescription TRuleClassifier::st_classDescription = { "TRuleClassifier", &typeid(TRuleClassifier), &TClassifier::st_classDescription, TRuleClassifier_properties, TRuleClassifier_components };
TClassDescription const *TRuleClassifier::classDescription() const { return &TRuleClassifier::st_classDescription; }


/****** TRuleClassifier_firstRule *****/


TPropertyDescription TRuleClassifier_firstRule_properties[] = {
  {"prior", "prior distribution", &typeid(POrange), &TDistribution::st_classDescription, offsetof(TRuleClassifier_firstRule, prior), false, false, 0},
  {"rules", "", &typeid(POrange), &TRuleList::st_classDescription, offsetof(TRuleClassifier_firstRule, rules), false, false, 0},
  {"examples", "", &typeid(POrange), &TExampleTable::st_classDescription, offsetof(TRuleClassifier_firstRule, examples), false, false, 0},
  {"weight_ID", "", &typeid(int), NULL, offsetof(TRuleClassifier_firstRule, weightID), false, false, 0},
  {"class_var", "class variable", &typeid(POrange), &TVariable::st_classDescription, offsetof(TRuleClassifier_firstRule, classVar), false, false, 0},
  {"computes_probabilities", "set if classifier computes class probabilities (if not, it assigns 1.0 to the predicted)", &typeid(bool), NULL, offsetof(TRuleClassifier_firstRule, computesProbabilities), false, false, 0},
  {NULL}
};

size_t const TRuleClassifier_firstRule_components[] = { offsetof(TRuleClassifier_firstRule, prior), offsetof(TRuleClassifier_firstRule, rules), offsetof(TRuleClassifier_firstRule, examples), offsetof(TRuleClassifier_firstRule, classVar), 0};
TClassDescription TRuleClassifier_firstRule::st_classDescription = { "TRuleClassifier_firstRule", &typeid(TRuleClassifier_firstRule), &TRuleClassifier::st_classDescription, TRuleClassifier_firstRule_properties, TRuleClassifier_firstRule_components };
TClassDescription const *TRuleClassifier_firstRule::classDescription() const { return &TRuleClassifier_firstRule::st_classDescription; }
TOrange *TRuleClassifier_firstRule::clone() const { return mlnew TRuleClassifier_firstRule(*this); }


/****** TLogitClassifierState *****/


TPropertyDescription TLogitClassifierState_properties[] = {
  {"rules", "", &typeid(POrange), &TRuleList::st_classDescription, offsetof(TLogitClassifierState, rules), false, false, 0},
  {"examples", "", &typeid(POrange), &TExampleTable::st_classDescription, offsetof(TLogitClassifierState, examples), false, false, 0},
  {"avg_prob", "", &typeid(POrange), &TFloatList::st_classDescription, offsetof(TLogitClassifierState, avgProb), false, false, 0},
  {"avg_prior_prob", "", &typeid(POrange), &TFloatList::st_classDescription, offsetof(TLogitClassifierState, avgPriorProb), false, false, 0},
  {"prefix_rules", "", &typeid(POrange), &TIntList::st_classDescription, offsetof(TLogitClassifierState, prefixRules), false, false, 0},
  {NULL}
};

size_t const TLogitClassifierState_components[] = { offsetof(TLogitClassifierState, rules), offsetof(TLogitClassifierState, examples), offsetof(TLogitClassifierState, avgProb), offsetof(TLogitClassifierState, avgPriorProb), offsetof(TLogitClassifierState, prefixRules), 0};
TClassDescription TLogitClassifierState::st_classDescription = { "TLogitClassifierState", &typeid(TLogitClassifierState), &TOrange::st_classDescription, TLogitClassifierState_properties, TLogitClassifierState_components };
TClassDescription const *TLogitClassifierState::classDescription() const { return &TLogitClassifierState::st_classDescription; }
TOrange *TLogitClassifierState::clone() const { return mlnew TLogitClassifierState(*this); }


/****** TRuleClassifier_logit *****/


TPropertyDescription TRuleClassifier_logit_properties[] = {
  {"prior", "prior distribution", &typeid(POrange), &TDistribution::st_classDescription, offsetof(TRuleClassifier_logit, prior), false, false, 0},
  {"domain", "Domain", &typeid(POrange), &TDomain::st_classDescription, offsetof(TRuleClassifier_logit, domain), false, false, 0},
  {"rule_betas", "Rule betas", &typeid(POrange), &TFloatList::st_classDescription, offsetof(TRuleClassifier_logit, ruleBetas), false, false, 0},
  {"min_significance", "minimum requested significance for betas. ", &typeid(float), NULL, offsetof(TRuleClassifier_logit, minSignificance), false, false, 0},
  {"min_beta", "minimum beta by rule to be included in the model. ", &typeid(float), NULL, offsetof(TRuleClassifier_logit, minBeta), false, false, 0},
  {"set_prefix_rules", "should we order prefix rules ? ", &typeid(bool), NULL, offsetof(TRuleClassifier_logit, setPrefixRules), false, false, 0},
  {"optimize_betas_flag", "should we assign betas to rules ? ", &typeid(bool), NULL, offsetof(TRuleClassifier_logit, optimizeBetasFlag), false, false, 0},
  {"penalty", "", &typeid(float), NULL, offsetof(TRuleClassifier_logit, penalty), false, false, 0},
  {"prior_classifier", "prior classifier used if provided", &typeid(POrange), &TClassifier::st_classDescription, offsetof(TRuleClassifier_logit, priorClassifier), false, false, 0},
  {"current_state", "", &typeid(POrange), &TLogitClassifierState::st_classDescription, offsetof(TRuleClassifier_logit, currentState), false, false, 0},
  {"wsd", "", &typeid(POrange), &TFloatList::st_classDescription, offsetof(TRuleClassifier_logit, wsd), false, false, 0},
  {"wavg_cov", "", &typeid(POrange), &TFloatList::st_classDescription, offsetof(TRuleClassifier_logit, wavgCov), false, false, 0},
  {"w_sat_q", "", &typeid(POrange), &TFloatList::st_classDescription, offsetof(TRuleClassifier_logit, wSatQ), false, false, 0},
  {"wsig", "", &typeid(POrange), &TFloatList::st_classDescription, offsetof(TRuleClassifier_logit, wsig), false, false, 0},
  {"prefix_rules", "rules that trigger before logit sum.", &typeid(POrange), &TRuleList::st_classDescription, offsetof(TRuleClassifier_logit, prefixRules), false, false, 0},
  {"rules", "", &typeid(POrange), &TRuleList::st_classDescription, offsetof(TRuleClassifier_logit, rules), false, false, 0},
  {"examples", "", &typeid(POrange), &TExampleTable::st_classDescription, offsetof(TRuleClassifier_logit, examples), false, false, 0},
  {"weight_ID", "", &typeid(int), NULL, offsetof(TRuleClassifier_logit, weightID), false, false, 0},
  {"class_var", "class variable", &typeid(POrange), &TVariable::st_classDescription, offsetof(TRuleClassifier_logit, classVar), false, false, 0},
  {"computes_probabilities", "set if classifier computes class probabilities (if not, it assigns 1.0 to the predicted)", &typeid(bool), NULL, offsetof(TRuleClassifier_logit, computesProbabilities), false, false, 0},
  {NULL}
};

size_t const TRuleClassifier_logit_components[] = { offsetof(TRuleClassifier_logit, prior), offsetof(TRuleClassifier_logit, domain), offsetof(TRuleClassifier_logit, ruleBetas), offsetof(TRuleClassifier_logit, priorClassifier), offsetof(TRuleClassifier_logit, currentState), offsetof(TRuleClassifier_logit, wsd), offsetof(TRuleClassifier_logit, wavgCov), offsetof(TRuleClassifier_logit, wSatQ), offsetof(TRuleClassifier_logit, wsig), offsetof(TRuleClassifier_logit, prefixRules), offsetof(TRuleClassifier_logit, rules), offsetof(TRuleClassifier_logit, examples), offsetof(TRuleClassifier_logit, classVar), 0};
TClassDescription TRuleClassifier_logit::st_classDescription = { "TRuleClassifier_logit", &typeid(TRuleClassifier_logit), &TRuleClassifier::st_classDescription, TRuleClassifier_logit_properties, TRuleClassifier_logit_components };
TClassDescription const *TRuleClassifier_logit::classDescription() const { return &TRuleClassifier_logit::st_classDescription; }
TOrange *TRuleClassifier_logit::clone() const { return mlnew TRuleClassifier_logit(*this); }
